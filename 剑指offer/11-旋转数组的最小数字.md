### 11-旋转数组的最小数字

​	题目描述

> 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

​	示例

```java
// 1
输入：[3,4,5,1,2]
输出：1
// 2
输入：[2,2,2,0,1]
输出：0
```

### 1：排序

- 无论是有序数组亦或者时无序数组，只需将其排序输出数组中的第一个元素即可。

> 时间复杂度：`O(nlog n)`，空间复杂度：`O(1)`

### 2：循环

- 维护一个最小变量`res`
- 在遍历数组的过程中，将每个数组元素与`res`比较

> 时间复杂度：`O(n)`，空间复杂度：`O(1)`

### 3：二分：本题考点

- 看到排序数组就要想到**二分法**，那么对于本题：**局部排序的数组**能否使用二分法？
- 例如：`[3,4,5,1,2]`。我们可以将`1`看成旋转点，`1`也是该数组中的最小数字
- `i = 0, j = len - 1`，将`i,j`指向数组的左右两端；`mid=left+(right-left)/2`，`mid`指向中心位置
- 通过比较`mid位置与right位置`对应的值，来判断**mid在左排序数组内还是右排序数组内**
  1. `nums[mid]>nums[right]`：mid一定在左排序数组中。即：旋转点在`[mid+1, right]`内
  2. `nums[mid]<nums[right]`：mid一定在右排序数组中。即：旋转点在`[left, mid]`内
  3. `nums[mid]=nums[right]`：无法判断，缩小范围。即：`right = right - 1`

```java
public int minArray(int[] numbers) {
    int l = 0, r = numbers.length - 1;
    while (l < r) {
        int mid = (r - l) / 2 + l;
        if(numbers[mid]>numbers[r]) {
            l = mid + 1;
        } else if(numbers[mid]<numbers[r]) {
            r = mid;
        } else {
            r--;
        }
    }
    return numbers[l];
}
```

> 时间复杂度：`O(log n)`，空间复杂度：`O(1)`