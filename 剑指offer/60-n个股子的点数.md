### 60-n个股子的点数

​	题目描述

> 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。
>
> 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。
>

​	示例

```java
输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
// 2
输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
```

​	提示

- `1 <= n <= 11`

### 1：动态规划

- 寻找状态：`dp[i][j]用来表示掷i个股子时所有股子朝上一面点数之和为j的次数`
- 状态转移方程：
  - 掷第`i`个股子后点数为`j`的情况可以由掷第`i-1`个股子点数为`j-6~j-1`之间转换过来
  - `j>k`时：`dp[i][j] += dp[i-1][j-k]`；`j<k`时，`dp[i][j] += 0`
- 状态初始化：当只有一个股子时，每个点数出现1次数都为一，即：`dp[1][j]=1`
- 输出

```java
public double[] twoSum(int n) {
    int[][] dp = new int[n+1][6*n+1];
    double[] ans = new double[5*n+1];
    double all = Math.pow(6, n); // 分母
    for(int i = 1; i <= 6; i++) {
        dp[1][i] = 1;
    }

    for(int i = 1; i <= n; i++) {
        for(int j = i; j <= 6*n; j++) { 
            for(int k = 1; k <= 6; k++) { //每一个股子都有六面，其值对应1~6
                // 当j>k时，掷第i个股子后点数为j的情况可以由掷第i-1个股子点数为j-6~j-1之间转换过来
                dp[i][j] += j >= k ? dp[i-1][j-k] : 0;
                if(i == n) ans[j-i] = dp[i][j]/all;
            }
        }
    }

    return ans;
}
```

